\chapter{Prototípus koncepciója}
\comment{A prototípus program célja annak demonstrálása, hogy a program elkészült, helyesen működik, valamennyi feladatát teljesíti. A prototípus változat egy elkészült program kivéve a kifejlett grafikus interfészt. Ez a program is parancssorból futtatható és karakteres ernyőkezelést alkalmaz. Az ütemezés, az aktív objektumok kezelése megoldott. A business objektumok -a megjelenítésre vonatkozó részeket kivéve -valamennyi metódusa a végleges algoritmusokat kell, hogy tartalmazza. A megjelenítés és működtetés egy alfanumerikus képernyőn vezérelhető és követhető, ugyanakkor a vezérlés fájlból is történhet és a megjelenítés fájlba is logolható, ezzel megteremtve a rendszer tesztelésének lehetőségét. Különös figyelmet kell fordítani a parancssori interfész logikájára, felépítésére, valamint arra, hogy az mennyiben tükrözi és teszi láthatóvá a program működését, a beavatkozások hatásait.}
\comment{\hrule}
\comment{Amennyiben változott a modell:}
\setcounter{section}{-1}
\section{Változás hatása a modellre}
\subsection{Módosult osztálydiagram}
\comment{Az analízis modell osztálydiagramja a változások figyelembevételével.}
\subsection{Új vagy megváltozott metódusok}
\comment{Az analízis modell osztályleírásaiból azon metódusok újbóli felsorolása leírással együtt, amelyek a változtatás miatt módosultak vagy újonnan be lettek vezetve}
\textbf{A bevezetett új osztályok}
\subsubsection{Osztály1}
\begin{class-template-responsibility}
    Felelősség leírása
\end{class-template-responsibility}
\begin{class-template-baseclass}
    Ős-Ősosztály \baseclass Ősosztály... 
\end{class-template-baseclass}
\begin{class-template-method}
    \classitem{+B(A a) : void}{metódus B}
\end{class-template-method}
\textbf{A korábbi osztályokban történt módosítások}
\subsubsection{Osztály2}
\begin{class-template-responsibility}
    Felelősség leírása
\end{class-template-responsibility}
\begin{class-template-baseclass}
    Ős-Ősosztály \baseclass Ősosztály... 
\end{class-template-baseclass}
\begin{class-template-method}
    \classitem{+B(A a) : void}{metódus B}
\end{class-template-method}

\subsection{Szekvencia-diagramok}
\comment{Az analízis modell szekvenciadiagramjaiból a változás által érintett, előírt, módosítottdiagramok}
\diagram{img/BMElogo}{Megváltozott szekvenciák}{3cm}
\comment{\hrule}

\section{Prototípus interface-definíciója}
\comment{Definiálni kell a teszteket leíró nyelvet. Külön figyelmet kell fordítani arra, hogy ha a rendszer véletlen elemeket is tartalmaz, akkor a véletlenszerűség ki-bekapcsolható legyen, és a program determinisztikusan is tesztelhető legyen.}

\subsection{Az interfész általános leírása}
\comment{A protó (karakteres) input és output felületeit úgy kell kialakítani, hogy az input fájlból is vehető legyen illetőleg az output fájlba menthető legyen, vagyis kommunikációra csak a szabványos be- és kimenet használható.}

\subsection{Bemeneti nyelv}
\comment{Definiálni kell a teszteket leíró nyelvet. Külön figyelmet kell fordítani arra, hogy ha a rendszer véletlen elemeket is tartalmaz, akkor a véletlenszerűség ki-bekapcsolható legyen, és a program determinisztikusan is futtatható legyen. A szálkezelést is tesztelhető, irányítható módon kell megoldani. A programot egy adott konfigurációból is el kell tudni indítani, vagyis kell olyan parancs, amivel konkrét előre megadott állapotból indul a rendszer (pl. load).}

\begin{itemize}
    \item Parancs1
    \begin{itemize}
        \item Leírás:
        \item Opciók:
    \end{itemize}
    \item Parancs2
    \begin{itemize}
        \item Leírás:
        \item Opciók:
    \end{itemize}
\end{itemize}
Példák a bemeneti nyelvre:
\begin{verbatim}
    parancs1 arg1 arg2 arg3
    parancs2 arg1 arg2
\end{verbatim}

\comment{Ha szükséges, meg kell adni a konfigurációs (pl. pályaképet megadó) fájlok nyelvtanát is.}

\subsection{Kimeneti nyelv}
\comment{Egyértelműen definiálni kell, hogy az egyes bemeneti parancsok végrehajtása után előálló állapot milyen formában jelenik meg a szabványos kimeneten. A program képes legyen olyan kimenetet előállítani, amellyel az objektumok állapota ellenőrizhető (pl. save). Ebben az alfejezetben is precízen definiálni kell, hogy a kimenet nyelve milyen elemekből és milyen szintakszissal áll elő.}
\begin{verbatim}
    kimeneti szintaktika
\end{verbatim}

\section{Összes részletes use-case}
\begin{use-case}
    %név
    {Use-case Neve}
    %rövid leírás
    {Az eset rövid leírása}
    %aktorok
    {Aktorok}
    %forgatókönyv
    Forgatókönyv \newline 
    \textbf{A.1} Alternatíva
\end{use-case}

\section{Tesztelési terv}
\comment{A tesztelési tervben definiálni kell, hogy a be- és kimeneti fájlok egybevetésével miként végezhető el a program tesztelése. Meg kell adni teszt forgatókönyveket. Az egyes teszteket elég informálisan, szabad szövegként leírni. Teszt-esetenként egy-öt mondatban. Minden teszthez meg kell adni, hogy mi a célja, a proto mely funkcionalitását, osztályait stb. teszteli. Az alábbi táblázat minden teszt-esethez külön-külön elkészítendő.}

\test{Teszteset neve}{Leírás}{A végrehajtott teszt célja}

\section{Tesztelést támogató segéd- és fordítóprogramok specifikálása}
\comment{Specifikálni kell a tesztelést támogató segédprogramokat. Rövid bemutatással (elvárt funkcionalitás) specifikálni kell a tesztelést támogató segédprogramokat.}